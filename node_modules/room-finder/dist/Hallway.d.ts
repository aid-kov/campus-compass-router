import { Room } from "./Room";
import { Turn } from "./Turn";
import { Stairs } from "./Stairs";
import { Node } from "./node";
export declare type OneWay = "forward" | "backward" | false;
/**
 * This class represents a single hallway. The hallway may have turns,
 * but if you need a fork, you need to add another [[Hallway]] to the list
 * and connect them with 2 [[Fork]]s.
 */
export declare class Hallway<ForkName extends string, StairName extends string> {
    partList: (Room<ForkName> | Stairs<StairName> | Turn)[];
    readonly allowFrontConnectionsInMiddle: boolean;
    readonly oneWay: OneWay;
    /**
     *
     * @param partList - An array of every [[Room]], [[Stairs]], or [[Turn]] in the hallway.
     * You can choose arbitrarily which end of the hallway to start at, but make
     * sure to keep the sides and directions of the [[Room]]s, [[Stairs]], and [[Turn]]s
     * consistent with the direction you choose as forward.
     * @param allowFrontConnectionsInMiddle - If true, this hallway may have
     * [[Rooms]] and [[Stairs]] that are not at the ends of the hallway, but are
     * marked as FRONT. This is used by [[isValidBuilding]].
     * @param oneWay - false if you can travel both ways in this hallway.
     * "forward" if you can only travel from the first to the last element of this
     * hallway. "backward" if you can only travel from the last element to the first.
     */
    constructor(partList: (Room<ForkName> | Stairs<StairName> | Turn)[], { allowFrontConnectionsInMiddle, oneWay, }?: {
        allowFrontConnectionsInMiddle?: boolean;
        oneWay?: OneWay;
    });
    /**
     * @param - name The name of the room
     * @returns The index of the room, or -1 if there's no room with that name
     */
    getRoomInd(name: string): number;
    /**
     * @param roomInd - The index of the room in this hallway
     * @returns The id of the "closest" node to the given room within this hallway
     */
    idOfClosestNodeToIndex(roomInd: number, allowedConnections: (ForkName | StairName)[]): Node<ForkName, StairName>;
    /**
     * An array of all of the node IDs in this hallway.
     */
    get nodes(): {
        nodeId: Node<ForkName, StairName>;
        edgeLengthFromPreviousNodeInHallway: number;
    }[];
    /**
     * Gives the directions to get from one room to another in a single hallway
     * given the indices of the rooms in the hallway.
     * @param from - The index of the starting room
     * @param to - The index of the room to go to
     * @param isBeginningOfDirections - Are these directions the first set of
     * directions in the whole set of directions created in [[Building.getDirections]]?
     * @param isEndOfDirections - Are these directions the last set of directions
     * in the whole set of directions created in [[Building.getDirections]]?
     * @param entranceWasStraight - When we entered this hallway, were we going
     * straight (as opposed to turning left or right into this hallway)? (not
     * applicable if isBeginningOfDirections is true; in this case, the argument
     * is ignored)
     * @returns The directions. Steps are separated with newlines.
     */
    getDirectionsFromIndices(from: number, to: number, { isBeginningOfDirections, isEndOfDirections, entranceWasStraight, }: {
        isBeginningOfDirections: boolean;
        isEndOfDirections: boolean;
        entranceWasStraight: boolean;
    }): string;
}
